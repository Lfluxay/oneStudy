# 01、变量和常量

```yacas
一、常量（Constant）
定义：在程序运行过程中，其值不应该被修改的固定值
特点：理论上值保持不变，用于存储固定数据（如数学常数、配置参数等）
注意：Python 没有真正意义上的常量（没有语法强制限制修改），通常通过命名约定来表示常量
命名规则：通常使用全大写字母和下划线命名，如 PI、MAX_SIZE
示例：
PI = 3.1415926  # 约定为常量，代表圆周率
MAX_STUDENTS = 50  # 约定为常量，代表最大学生数
虽然语法允许修改，但不建议这样做
PI = 3.14  # 不推荐的操作

二、变量
变量（Variable）
什么是变量：变量是用于存储数据值的标识符，可通过变量名访问和操作这些数据，在程序中，变量就像一个容器，用于存储和管理数据
变量就是可以变化的量，量指的是事物的状态
为什么要有变量:
1、通过变量，程序可以在运时根据需要存储和修改数据，从而实现动态的状态和行为
2、为了让计算机能够像人一样去记忆事物的某种状态，并且是可以发生变化的
3、变量在程序中扮演着存储和传递信息的角色
程序执行的本质就是一系列状态的变化，变是程序执行的直接体现
所以我们要有一种机制能够反映或者说是保存下来程序执行时状态，以及变化的状态
例如：
res = 1

变量的定义与调用
三部分组成
变量名 + 赋值符号 + 变量值
res = 1
内部原理：在内存中开辟一块存储空间，让这个空间存储1这个值，并把内存地址指向res

变量的命名规范
1、遵循标识符规则（字母、数字、下划线组成，不能以数字/保留的关键字开头）
2、大小驼峰体

变量的三大特性
1、变量内存地址 id()
2、变量类型 type()
3、变量值
```



# 02、基本数据类型

八大基本数据类型：

```yacas
整型int、浮点型类型float、字符串str、列表list、集合set、字典dict、元组tuple、布尔bool
```

```python
1、整数类型：int
一、整数的基本特点
无长度限制
与许多编程语言不同，Python 整数的大小仅受限于系统内存，理论上可以表示任意大的整数，无需担心溢出问题。
python
运行
# 非常大的整数也能正常运算
big_num = 10 **1000  # 1后面跟1000个0
print(big_num)  # 正常输出这个极大的整数

2.** 支持正负值 ** 整数可以是正数、负数或零，符号通过+（可省略）和-表示：
python
运行
positive = 42    # 正整数
negative = -100  # 负整数
zero = 0         # 零
3.** 不可变类型 ** 整数创建后其值不能被修改，任何 “修改” 操作都会生成新的整数对象：
python
运行
x = 5
print(id(x))  # 输出内存地址：如 140708488844640
x = 6         # 实际创建了新的整数对象
print(id(x))  # 输出新的内存地址：如 140708488844672
###** 二、整数的表示形式 **Python 支持多种进制的整数表示，方便不同场景使用：
进制	前缀	示例（对应十进制 25）
十进制	无	25
二进制	0b 或 0B	0b11001
八进制	0o 或 0O	0o31
十六进制	0x 或 0X	0x19
python
运行
# 不同进制整数的十进制输出
print(0b11001)  # 输出：25（二进制转十进制）
print(0o31)     # 输出：25（八进制转十进制）
print(0x19)     # 输出：25（十六进制转十进制）

# 十进制转其他进制（通过内置函数）
print(bin(25))  # 输出：'0b11001'（十进制转二进制）
print(oct(25))  # 输出：'0o31'（十进制转八进制）
print(hex(25))  # 输出：'0x19'（十进制转十六进制）
三、整数的常用操作
算术运算
支持 +（加）、-（减）、*（乘）、/（除，结果为浮点数）、//（整除）、%（取余）、**（幂运算）等：
python
运行
print(15 + 3)   # 18
print(15 - 3)   # 12
print(15 * 3)   # 45
print(15 / 3)   # 5.0（结果为浮点数）
print(15 // 4)  # 3（整除，向下取整）
print(15 % 4)   # 3（取余）
print(15 **2)  # 225（平方运算）

类型转换
通过 int() 函数可将其他类型转换为整数：
python
运行
print(int(3.9))     # 3（浮点数转整数，截断小数部分）
print(int("123"))   # 123（字符串转整数，字符串需为纯数字）
print(int(True))    # 1（布尔值转整数：True=1，False=0）
print(int("111", 2))  # 7（将二进制字符串"111"转为十进制）

比较运算
支持 ==、!=、>、<、>=、<= 等，返回布尔值：
python
运行
print(10 == 10)  # True
print(10 > 5)    # True
print(10 != 7)   # True

四、整数的特殊机制
小整数缓存：Python 会对范围在 -5 到 256 之间的整数进行缓存，相同值的整数会复用同一个对象，以节省内存：
python
运行
a = 100
b = 100
print(a is b)  # True（同一对象）

c = 300
d = 300
print(c is d)  # False（超出缓存范围，不同对象）

总结
整数类型的核心优势在于无大小限制和灵活的进制支持，使其能轻松应对从简单计数到复杂数学运算的各种场景。无论是日常开发还是科学计算，整数类型都是不可或缺的基础数据类型。


2、浮点数类型：float
表示小数部分数值，适用于更精确表示的情况
salary = 100.301
print(type(salary))
注意精度丢失问题，通常需要加decimal
例如：
0.1 + 0.2  # 预期结果：0.3，实际结果：0.30000000000000004
0.1 * 3    # 预期结果：0.3，实际结果：0.30000000000000004
0.1 == 0.10000000000000001  # 结果：True（微小误差被忽略）
解决办法：
1、round()函数，四舍五入
result = 0.1 + 0.2
print(round(result, 1))  # 输出：0.3（保留1位小数）

2、整数运算
# 避免：0.1 + 0.2 = 0.30000000000000004
# 改用：1 + 2 = 3
a = 1  # 1
b = 2  # 2
result = (a + b) / 10  # 转换为：0.3

3、decimal模块
from decimal import Decimal, getcontext
# 高精度加法
a = Decimal('0.1')
b = Decimal('0.2')
print(a + b)  # 输出：0.3
# 控制精度（保留20位小数）
getcontext().prec = 20
c = Decimal('1') / Decimal('3')
print(c)  # 输出：0.33333333333333333333

4、fractions 模块（分数形式）
from fractions import Fraction
a = Fraction(1, 10)  # 1/10
b = Fraction(2, 10)  # 2/10
print(a + b)  # 输出：3/10（即0.3）
print(float(a + b))  # 输出：0.3

浮点数精度丢失是二进制存储机制导致的，无法彻底消除。
简单场景可用round()处理；
高精度场景（如金融计算）推荐 decimal 模块；
需完全精确时，可转换为整数或分数运算。
在实际需根据业务对精度的要求选择合适的处理方式，避免因精度问题导致逻辑错误（如金额计算错误）。

多位小数可进行科学计数法表示：
如：科学计数法：1e3（表示 1000.0）、2.5e-2（表示 0.025）



3、字符串类型：str
表示文本信息，是一种非常重要的数据类型，用于处理文字，字符等信息
name = "jack"
print(type(name))
# 语法
1、单引号、双引号、三单引号、三双引号，换行用反斜杠\衔接
内置双引号，外置单引号；
name = 'just like "this"'
内置单引号，外置双引号
name = "just like 'this'"

字符串使用方法：
数字乘法、字符串*数字、数字加法、字符串+数字（false）、字符串+字符串

字符串索引取值：
正向索引取值：索引下标从0开始
负向索引取值：索引下标从-1开始

字符串格式化输出：
1、%占位输出（占位类型：%s-字符串 %d-整型 %f-浮点型 %x十六进制）
sentence = "my name is %s"
print(sentence %("jay"))

2、{}占位，format传参（多个参数占位，数据类型位置错误导致报错:新版编译器解决此问题，参数前自动加入了*args）
sentence = "my name is {}, age is {}"
print(sentence.format(12,"jay"))
{变量名}占位
sentence = "my name is {name}, age is {age}"
print(sentence.format(name="jay",age=22))

3、f."{关键字}"占位
name = "jack"
age = 23
sentence = f"my name is {name}, age is {age}"
print(sentence)


字符串的切片:
通过 [起始:结束:步长] 截取子字符串（左闭右开）
s = "Python"
print(s[0])      # 'P'（第一个字符）
print(s[-1])     # 'n'（最后一个字符）
print(s[1:4])    # 'yth'（从索引1到3）
print(s[::2])    # 'Pto'（步长为2，间隔取字符）

字符串的常用操作：拼接、重复、成员判断（in/not in）

字符串常用内置函数:
大小写转换：upper()：大写、lower()：小写、capitalize()：首字母大写
查找替换：find()：查找、replace()：替换
去除空白：strip()、lstrip()、rstrip()
分割连接：split()、join()


4、列表类型：list
列表是一种有序、可变的容器类型，用于存储多个元素
有序性：元素按插入顺序排列，可通过索引访问（索引从 0 开始）。
可变性：可动态添加、删除或修改元素，修改后内存地址不变。
元素多样性：可包含不同类型的元素（如整数、字符串、列表等）。
可嵌套：列表中可以包含其他列表，形成多维结构。
解决取值问题，例如：
fruits = "apple, banana, cherry, date"
换成列表
fruits = ["apple", "banana", "cherry", "date"]

如上可以通过索引取值
0 1 2 3
索引：通过 [索引值] 访问单个元素（从 0 开始，支持负索引）
正向索引：从0开始，负向索引：从-1开始
print(fruits[1])

列表嵌套取值，从外到内
nested = [1, [2, 3], [4, [5, 6]]]
print(nested[2][1][0])

列表的切片：
切片：通过 [起始:结束:步长] 截取子列表（左闭右开）
nums = [10, 20, 30, 40, 50]
print(nums[2])       # 30（第三个元素）
print(nums[-1])      # 50（最后一个元素）
print(nums[1:4])     # [20, 30, 40]（从索引1到3）
print(nums[::2])     # [10, 30, 50]（步长为2）

列表的常用操作：拼接、重复、成员判断（in/not in）

常用函数方法：
添加元素：append()（末尾添加）、insert()（指定位置插入）、extend()（合并另一个列表）
删除元素：remove()（按值删除）、pop()（按索引删除，默认最后一个）、clear()（清空列表）
其他操作：index()（查找元素索引）、count()（统计元素出现次数）、sort()（排序）、reverse()（反转）

列表推导式：
格式为 [表达式 for 变量 in 可迭代对象 if 条件]
res = [x**2 for i in range(1,10)]
print(res)




5、字典类型：dict
列表中可以存储多个属性类型相同的值，但是如果需要取值具体，可能无法区分，如通过索引取值，不能明确表示具体值的含义，于是我们要用一个变量记录多个值，但多个值是不同属性的，所以就要用到字典类型

字典类型使用key：value形式存储数据，key可以对value又描述性的功能

字典（Dictionary）是一种无序、可变的数据类型，用于存储键值对（key-value）映射关系。字典用大括号 {} 表示，键和值之间用冒号 : 分隔，键值对之间用逗号 , 分隔

语法：{"key":"value"}
1、直接定义字典
personInfo = {
  "name":"jack",
  "age":18,
  "habbit":"basketball"
}
2、空字典
empty_dict = {}
res_dict = dict()   #函数创建
3、键值对序列创建
dict_from_tuples = dict([("a", 1), ("b", 2)]) # {"a": 1, "b": 2}

键的特性：
键必须是不可变类型（如整数、字符串、元组），不能用列表等可变类型作为键
键必须唯一，重复的键会被最后一个值覆盖
如:
合法:
  res_dict = {1:"one", "two":2, (3):"three"}
非法:
  duplicate_key = {"a": 1, "a": 2}
  print(duplicate_key)  # {"a": 2}  # 重复键会被覆盖

字典常用方法  
字典取值
方式1：直接输出key(字典中无对应key值则输出报错)
print(personInfo["name"])
方式2：字典.get[key]（字典中无对应key值则输出None不报错）
print(personInfo.get["habbit"])
print(personInfo.get("orange", 0))  # 0（键"orange"不存在，返回默认值0）

字典修改值
personInfo["name"] = "jay"
print(personInfo["name"])

字典添加新键值对
personInfo["city"] = "HK"
print(personInfo)

字典删除元素
car = {"brand":"fcous","year": 2012}
del dict[key]:删除指定键的键值对
del car["year"]
print(car)

pop(key, default):删除并返回指定键的值，键不存在则返会默认值
car = {"brand": "Toyota", "year": 2020}
del car["year"]
print(car)  # {"brand": "Toyota"}
brand = car.pop("brand")
print(brand)  # "Toyota"
print(car)    # {}


clear():清空字典所有元素
car = {"brand": "Toyota", "year": 2020}
print(car.clear()) # None


获取键、值、键值对
keys()：返回所有键的视图
values()：返回所有值的视图
items()：返回所有键值对的视图（每个元素是 (key, value) 元组）
book = {"title": "Python", "author": "John", "pages": 300}
print(list(book.keys()))    # ["title", "author", "pages"]
print(list(book.values()))  # ["Python 101", "John", 300]
print(list(book.items()))   # [("title", "Python 101"), ("author", "John"), ("pages", 300)]

其他常用方法：
update(other_dict):用另一个字典的键值更新当前字典（覆盖）
copy():复制字典（浅拷贝）
res1 = {"a":1, "b":2}
res2 = {"b":3, "d":4}
print(res1,res2) # {'a': 1, 'b': 2} {'c': 3, 'd': 4}
res1.update(res2) 
print(res1) # {'a': 1, 'b': 3, 'd': 4} 覆盖b，新增d

字典的推导式
格式通常为：{键值表达式：值表达式 for 变量 in 可迭代对象 if 条件}
# 创建数字到其平方的字典
res1_dict = {x: x**2 for x in range(1,11)}
print(res1_dict)
# 筛选值为偶数的键值对
res2_dict = {k: v for k, v in res1_dict.items() if v % 2 == 0}
print(res2_dict)

字典适合通过键快速查找、添加、删除元素，时间复杂度为 O (1)，比列表的索引查找更高效（尤其是数据量大时）

列表和字典的嵌套组合
info = {
  "name":"jay",
  "address":{
    "国家":"cn",
    "info":[66,55,{"邮编":1234,"habbit":["read","music"]}]
  }
}
# 逐层访问：先取 address 字典，再取其中的 info 列表
nested_info = info["address"]["info"]
print(nested_info) # 输出：[66, 55, {'邮编': 1234, 'habbit': ['read', 'music']}]
# 获取列表中的第一个元素（66）
print(nested_info[0])  # 66 
# 获取列表中第三个元素（字典）的 "邮编"
print(nested_info[2]["邮编"])  # 1234
# 获取 "habbit" 列表中的第二个元素
print(nested_info[2]["habbit"][1])  # "music"




6、布尔类型：bool
布尔类型（Boolean）是一种表示逻辑值的数据类型
只有两个可能的值：True（真）和 False（假）
布尔类型通常用于条件判断、逻辑运算等场景
用于判断/循环...
语法 变量名 = True / False
is_active = True
has_error = False
print(type(is_active))  # <class 'bool'>（查看类型）

与其他类型的转换：
可以通过bool()函数将其他类型转换成布尔值
以下值会被转换为 False：
  数值 0（包括整数 0、浮点数 0.0 等）
  空序列 / 集合（空字符串 ""、空列表 []、空字典 {}、空集合 set() 等）
  None（表示空值）
其他所有值都会被转换为 True
如：
print(bool(0))       # False
print(bool(""))      # False
print(bool([]))      # False
print(bool(None))    # False

print(bool(1))       # True
print(bool("hello")) # True
print(bool([1,2]))   # True
print(bool(" "))     # True

逻辑运算：
布尔类型支持三种基本逻辑运算：
and与：两边都为True时，结果才为True
or或：两边有一个True时，结果就为True
not非：取反，not True 为 False， not False 为 True

a = True
b = False
print(a and b)  #False
print(a or b)   #True
print(not a)    #False

比较运算符
比较运算符（==、!=、>、<、>=、<=）的运算结果是布尔值：
print(5 > 3)      # True
print(2 == 2)     # True
print("a" != "b") # True

应用场景
条件判断
if、while等语句中，决定是否运行代码块
age = 18
if age >= 18:
  print("已成年")
else：
	print("未成年")

过滤数据
结合列表推导式等方式筛选符合条件的数据
nums = [1, -2, 3, -4, 5]
positive_nums = [n for n in nums if n > 0]
print(positive_nums) # [1, 3, 5]

注:true 和 false在数值运算中可以当做1 和 0 处理
print(True + 1)  # 2（True 等价于 1）
print(False * 5) # 0（False 等价于 0）
避免将布尔值与其他类型直接比较
应使用 is 判断身份（如 if flag is True），简化为 if flag




7、元组类型：tuple
有序、不可变的序列类型，类似列表，用于存储多个有序元素，可以是不同数据类型
元组用圆括号 () 表示，元素之间用逗号分隔，也可以省略括号直接用逗号分隔元素

定义方式：
普通元组:
  fruits = ("apple", "banana", "cherry")

单个元素的元组，必须加逗号，否则或当做普通数据类型
	single_tuple = ("hello",)

省略括号类型元组：
	colors = "red", "green", "blue"
  
空元组：
empty = ()
empty_tuple2 = tuple()  # 通过 tuple() 函数创建

有序性：
元组中的元素有固定顺序，可以通过索引访问（与列表相同）：
t = ("a", "b", "c")
print(t[0])   # "a"（第一个元素）
print(t[-1])  # "c"（最后一个元素）

支持多种数据类型：
元组可以包含不同类型的元素，甚至可以嵌套元组：
mixed_tuple = (1, "hello", 3.14, (4, 5))
print(mixed_tuple[3])  # (4, 5)（访问嵌套的元组）

元组的常用操作
索引与切片：
元组支持与列表相同的索引和切片操作：
t = (10, 20, 30, 40, 50)
print(t[1:4])   # (20, 30, 40)（切片，左闭右开）
print(t[::2])   # (10, 30, 50)（步长为2）

拼接与重复：
可以通过 + 拼接元组，通过 * 重复元组（操作会生成新元组，原元组不变）：
a = (1, 2)
b = (3, 4)
print(a + b)    # (1, 2, 3, 4)（拼接）
print(a * 2)    # (1, 2, 1, 2)（重复）

成员判断：
使用 in 或 not in 判断元素是否在元组中：
t = ("x", "y", "z")
print("y" in t)     # True
print("a" not in t) # True

常用方法：
元组的方法较少（因不可变），主要有两个：
count(x)：统计元素 x 在元组中出现的次数
index(x)：返回元素 x 在元组中首次出现的索引（若不存在则报错）
t = (1, 2, 2, 3, 2)
print(t.count(2))   # 3（数字2出现了3次）
print(t.index(3))   # 3（数字3首次出现在索引3的位置）

元组的应用场景
存储不可变数据：
当数据创建后不希望被修改时（如配置信息、坐标等），适合用元组：
# 存储经纬度（不希望被修改）
coordinates = (39.9042, 116.4074)

作为函数返回值：
函数可以通过元组返回多个值，调用时可自动解包：
def get_user_info():
    name = "Alice"
    age = 30
    return name, age  # 实际返回的是元组 (name, age)

user_name, user_age = get_user_info()  # 解包元组
print(user_name)  # "Alice"

作为字典的键：
元组是不可变类型，可作为字典的键（列表不行）：
# 合法：元组作为键
valid_dict = {("a", 1): "value"}

# 报错：列表不能作为键
# invalid_dict = {["a", 1]: "value"}

注意事项
元组的不可变性是指元素的引用不可变，若元素本身是可变类型（如列表），则元素内部可以修改：
t = (1, [2, 3])
t[1].append(4)  # 合法：修改元组中的列表元素
print(t)  # (1, [2, 3, 4])
元组比列表更节省内存，且访问速度更快，适合存储固定数据。
元组的不可变性使其在需要数据安全（防止意外修改）的场景中非常有用，同时保留了序列类型的基本操作特性



  
8、集合类型：set
是一种无序、可变的数据类型，用于存储唯一的元素（自动去重）
集合用大括号 {} 表示，元素之间用逗号分隔，也可通过 set() 函数创建

定义方式：
# 直接定义集合
fruits = {"apple", "banana", "cherry"}

# 空集合（注意：{} 表示空字典，空集合必须用 set()）
empty_set = set()

# 从其他可迭代对象转换（自动去重）
numbers = [1, 2, 2, 3, 4, 4]
unique_nums = set(numbers)  # {1, 2, 3, 4}

唯一性：
集合中不会有重复元素，添加重复值会被自动忽略：
s = {1, 2, 2, 3}
print(s)  # {1, 2, 3}（重复的2被去除）

无序性：
集合中的元素没有固定顺序，不能通过索引访问：
s = {"a", "b", "c"}
# print(s[0])  # 报错：'set' object does not support indexing

可变性：
可以动态添加或删除元素，但元素必须是不可变类型（如整数、字符串、元组），不能包含列表、字典等可变类型：
# 合法集合
valid_set = {1, "hello", (2, 3)}

# 非法集合（包含列表）
# invalid_set = {1, [2, 3]}  # 报错

集合的常用操作
添加元素：
add(x)：添加单个元素（若已存在则不操作）
update(iterable)：添加多个元素（接收列表、元组等可迭代对象）
s = {1, 2}
s.add(3)
print(s)  # {1, 2, 3}

s.update([4, 5, 2])  # 添加列表，2已存在会被忽略
print(s)  # {1, 2, 3, 4, 5}

删除元素：
remove(x)：删除元素 x，若 x 不存在则报错
discard(x)：删除元素 x，若 x 不存在则不操作
pop()：随机删除并返回一个元素（因集合无序）
clear()：清空集合
s = {1, 2, 3}
s.discard(2)
print(s)  # {1, 3}

s.pop()
print(s)  # {3}（或 {1}，取决于随机删除的元素）

集合运算（数学意义）：
支持交集、并集、差集等经典集合操作：
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# 并集（所有元素，去重）
print(a | b)  # {1, 2, 3, 4, 5, 6}  等价于 a.union(b)

# 交集（共同元素）
print(a & b)  # {3, 4}  等价于 a.intersection(b)

# 差集（a有而b没有的元素）
print(a - b)  # {1, 2}  等价于 a.difference(b)

# 对称差集（a和b中互不相同的元素）
print(a ^ b)  # {1, 2, 5, 6}  等价于 a.symmetric_difference(b)

集合推导式：
快速创建集合的简洁语法：
# 生成1-10中的偶数集合
even_set = {x for x in range(1, 11) if x % 2 == 0}
print(even_set)  # {2, 4, 6, 8, 10}

不可变集合（frozenset）
如果需要不可修改的集合（可作为字典的键或其他集合的元素），可以使用 frozenset：
fs = frozenset({1, 2, 3})
# fs.add(4)  # 报错：'frozenset' object has no attribute 'add'

应用场景
去重：快速去除列表等可迭代对象中的重复元素
成员判断：高效检查元素是否存在（比列表的 in 操作更快）
集合运算：如筛选两个列表的共同元素、差异元素等
```

### 可变数据类型和不可变数据类型

#### **一、核心区别**

- **不可变数据类型**：创建后其值**不能被直接修改**，若修改会生成新的对象。
- **可变数据类型**：创建后其值**可以被直接修改**，修改后不会生成新的对象（内存地址不变）。

#### **二、具体分类**

##### 1. 不可变数据类型

常见的不可变类型包括：`int`（整数）、`float`（浮点数）、`str`（字符串）、`tuple`（元组）、`bool`（布尔值）。

**特点**：
修改值时会创建新对象，原对象的内存地址不变。

**示例**：

```python
# 字符串（不可变）
s = "hello"
print(id(s))  # 输出：140525426721648（内存地址）

s += " world"  # 看似修改，实际创建了新字符串
print(id(s))  # 输出：140525426802544（新的内存地址）

# 元组（不可变）
t = (1, 2, 3)
# t[0] = 4  # 报错：'tuple' object does not support item assignment
```

##### 2. 可变数据类型

常见的可变类型包括：`list`（列表）、`dict`（字典）、`set`（集合）。

**特点**：
可以直接修改值，内存地址保持不变。

**示例**：

```python
# 列表（可变）
lst = [1, 2, 3]
print(id(lst))  # 输出：140525426560448

lst.append(4)  # 直接修改列表
print(id(lst))  # 输出：140525426560448（地址不变）

# 字典（可变）
d = {"name": "Alice"}
print(id(d))  # 输出：140525426622656

d["age"] = 20  # 直接修改字典
print(id(d))  # 输出：140525426622656（地址不变）
```

#### **三、深层影响**

1. **变量赋值与引用**

   - 不可变类型：赋值时会复制值（或引用新对象）

     ```python
     a = 10
     b = a  # b 指向 a 的值（10）
     a = 20  # a 指向新对象（20），b 仍指向 10
     print(b)  # 输出：10
     ```

   - 可变类型：赋值时传递的是引用（内存地址），修改一个变量会影响另一个。

     ```python
     lst1 = [1, 2]
     lst2 = lst1  # lst2 与 lst1 指向同一列表
     lst1.append(3)
     print(lst2)  # 输出：[1, 2, 3]（lst2 也被修改）
     ```

2. **函数参数传递**

   - 不可变类型作为参数：函数内修改不会影响外部变量。
   - 可变类型作为参数：函数内修改会影响外部变量。

   ```python
   def modify(x, lst):
       x = 100  # 不影响外部 x
       lst.append(100)  # 影响外部列表
   
   a = 10
   b = [1, 2]
   modify(a, b)
   print(a)  # 输出：10
   print(b)  # 输出：[1, 2, 100]
   ```

##### **总结**

- **不可变类型**：值不可改，修改即创建新对象（如 `str`、`tuple`）。
- **可变类型**：值可直接修改，内存地址不变（如 `list`、`dict`）。

理解这一特性有助于避免代码中的意外修改，尤其是在处理函数参数和变量引用时。



### 容器类型和基本数据类型

##### 核心区别:在于是否能存储多个值或复杂结构

#### **一、基本数据类型（Primitive Types）**

基本数据类型是用于存储**单一、简单值**的类型，它们通常直接对应计算机底层的数据表示方式。

##### 常见类型：

1. **整数（int）**：如 `10`、`-5`、`0`，可表示任意大小的整数。
2. **浮点数（float）**：如 `3.14`、`-0.5`，表示带小数的数值（精度有限）。
3. **布尔值（bool）**：仅 `True`（真）和 `False`（假）两个值，用于逻辑判断。
4. **字符串（str）**：如 `'hello'`、`"Python"`，由字符组成的文本序列（注意：字符串虽由多个字符组成，但在 Python 中被视为基本类型，因其不可变且操作方式更接近单一值）。
5. **NoneType**：仅 `None` 一个值，表示 “空” 或 “无”。

##### 特点：

- 存储单一值，不可直接包含其他数据类型。
- 多数为**不可变类型**（如 `int`、`float`、`str`、`bool`），修改时会创建新对象。
- 操作简单，通常用于直接表示数据本身（如数字、文本、逻辑状态）。

**示例**：

```python
num = 42          # int
pi = 3.14159      # float
is_valid = True   # bool
name = "Alice"    # str
empty = None      # NoneType
```

#### **二、容器类型（Container Types）**

容器类型用于存储**多个值或多个数据类型的组合**，可以将其他数据（包括基本类型和其他容器类型）组织成更复杂的结构。

##### 常见类型：

1. **列表（list）**：如 `[1, 2, 'a']`，有序、可变的元素集合，支持索引访问和动态修改。
2. **元组（tuple）**：如 `(1, 2, 'a')`，有序、不可变的元素集合，常用于存储固定搭配的数据。
3. **字典（dict）**：如 `{'name': 'Bob', 'age': 20}`，由键值对组成的无序集合，通过键快速查找值。
4. **集合（set）**：如 `{1, 2, 3}`，无序、不重复的元素集合，适合去重和集合运算。

##### 特点：

- 可包含多个值，且元素类型可以不同（如列表可同时包含 `int`、`str`、`list` 等）。
- 多数为**可变类型**（如 `list`、`dict`、`set`），可直接修改内部元素而不改变自身内存地址（元组是例外，不可变）。
- 用于组织和管理复杂数据结构，如批量存储数据、表示实体属性（字典）、维护有序序列（列表）等。

**示例**：

```python
fruits = ['apple', 'banana', 'orange']  # list
person = ('Alice', 30, 'female')        # tuple
info = {'name': 'Bob', 'hobbies': ['reading', 'sports']}  # dict（嵌套列表）
unique_nums = {1, 2, 2, 3}              # set（自动去重为 {1,2,3}）
```

##### **三、核心区别总结**

| 维度     | 基本数据类型                  | 容器类型                       |
| -------- | ----------------------------- | ------------------------------ |
| 存储内容 | 单一值                        | 多个值或复杂组合               |
| 可变性   | 多数不可变（如 `str`、`int`） | 多数可变（如 `list`、`dict`）  |
| 用途     | 表示简单数据（数字、文本等）  | 组织复杂数据结构               |
| 嵌套能力 | 不能直接包含其他类型          | 可嵌套其他类型（包括容器类型） |

理解两者的区别有助于合理选择数据类型：存储单一值用基本类型，管理多个相关数据用容器类型，这是编写清晰、高效代码的基础





### 基本运算符

#### 1、算数运算符

用于数值计算，包括：

| 运算符 | 描述                 | 示例                |
| ------ | -------------------- | ------------------- |
| `+`    | 加法                 | `3 + 5 → 8`         |
| `-`    | 减法                 | `10 - 4 → 6`        |
| `*`    | 乘法                 | `4 * 7 → 28`        |
| `/`    | 除法（结果为浮点数） | `10 / 3 → 3.333...` |
| `//`   | 整除（向下取整）     | `10 // 3 → 3`       |
| `%`    | 取余（模运算）       | `10 % 3 → 1`        |
| `**`   | 幂运算               | `2** 3 → 8`         |

*和+ 可以用于字符串、列表

print("a"+"b")

Print([1, 2] * 3)

#### 2、赋值运算符

用于给变量赋值，基础形式为 `=`，还有复合赋值：

| 运算符 | 描述       | 等价形式               |
| ------ | ---------- | ---------------------- |
| `=`    | 基础赋值   | `x = 5`                |
| `+=`   | 加法赋值   | `x += 3 → x = x + 3`   |
| `-=`   | 减法赋值   | `x -= 2 → x = x - 2`   |
| `*=`   | 乘法赋值   | `x *= 4 → x = x * 4`   |
| `/=`   | 除法赋值   | `x /= 2 → x = x / 2`   |
| `//=`  | 整除赋值   | `x //= 3 → x = x // 3` |
| `%=`   | 取余赋值   | `x %= 5 → x = x % 5`   |
| `**=`  | 幂运算赋值 | `x**= 2 → x = x **2`   |

```python
x = 10
x += 5  # 等价于 x = x + 5 → x 变为 15
交叉赋值
a = 1
b = 2
a, b = b, a
链式赋值
a = b = c = 3
解压赋值
num_list = [1,2,3]
a, b, c = num_list
# 列表元素个数>变量,则报错
# 列表元素个数<变量，也报错
# 可以用下划线替代不需要赋值的变量 
```

#### 3、比较运算符

用于比较两个值，返回布尔值（`True`/`False`）：

| 运算符 | 描述     | 示例             |
| ------ | -------- | ---------------- |
| `==`   | 等于     | `5 == 5 → True`  |
| `!=`   | 不等于   | `5 != 3 → True`  |
| `>`    | 大于     | `6 > 2 → True`   |
| `<`    | 小于     | `3 < 1 → False`  |
| `>=`   | 大于等于 | `4 >= 4 → True`  |
| `<=`   | 小于等于 | `2 <= 1 → False` |

示例：

```python
print(3 > 5)       # False
print("a" == "A")  # False（字符串区分大小写）
```

#### 4、逻辑运算符

用于组合布尔值，进行逻辑判断：

| 运算符 | 描述   | 运算规则                          |
| ------ | ------ | --------------------------------- |
| `and`  | 逻辑与 | 两边都为 `True` 则结果为 `True`   |
| `or`   | 逻辑或 | 至少一边为 `True` 则结果为 `True` |
| `not`  | 逻辑非 | 取反（`not True → False`）        |

示例：

```python
a = True
b = False
print(a and b)  # False
print(a or b)   # True
print(not a)    # False

逻辑运算符优先级:
  not > and > or
	提高优先级可使用()
```

**短路特性**：

- `and` 若左边为 `False`，则直接返回 `False`（不计算右边）
- `or` 若左边为 `True`，则直接返回 `True`（不计算右边）

#### 5、成员运算符

判断元素是否在序列（列表、字符串、集合等）中：

| 运算符   | 描述                    |
| -------- | ----------------------- |
| `in`     | 元素在序列中 → `True`   |
| `not in` | 元素不在序列中 → `True` |

示例：

```python
fruits = ["apple", "banana"]
print("apple" in fruits)     # True
print("orange" not in fruits) # True
```

#### 6、身份运算符

判断两个变量是否指向**同一个对象**（内存地址相同）：

| 运算符   | 描述                          |
| -------- | ----------------------------- |
| `is`     | 两个变量指向同一对象 → `True` |
| `is not` | 两个变量指向不同对象 → `True` |

示例：

```python
a = [1, 2]
b = a
c = [1, 2]
print(a is b)    # True（a和b指向同一列表）
print(a is c)    # False（a和c是不同对象，尽管值相同）
```

**注意**：`==` 判断值是否相等，`is` 判断是否为同一对象（内存地址）

#### 7、位运算符

对二进制位进行操作（较少用于日常开发）：

| 运算符 | 描述     | 示例（二进制）                 |       |              |
| ------ | -------- | ------------------------------ | ----- | ------------ |
| `&`    | 按位与   | `1010 & 1100 → 1000`           |       |              |
| `      | `        | 按位或                         | `1010 | 1100 → 1110` |
| `^`    | 按位异或 | `1010 ^ 1100 → 0110`           |       |              |
| `~`    | 按位取反 | `~1010 → 0101`（符号位会变化） |       |              |
| `<<`   | 左移     | `1010 << 1 → 10100`            |       |              |
| `>>`   | 右移     | `1010 >> 1 → 0101`             |       |              |



# 03、流程控制语句

### 什么是流程控制语句？

### 流程控制的三种方式

#### 1、顺序结构---->按照顺序执行代码



#### 2、分支结构---->存在条件约束，达到了某个条件才会执行代码

单分支结构：

​	程序在运行过程中，如果达到了某个条件，就会执行该条件下的代码

```python
score = 89
if score > = 90:
  print(f"优秀")
```

双分支结构：

​	程序在运行过程中， 又两个条件，要么达到条件1执行条件1代码，要么达到条件2执行条件2代码

```python
score = 60
if score > = 90:
  print(f"优秀")
else:
  print(f"加油")
```

多分支结构：

​	程序在运行过程中有多个条件进行约束和判断，当程序执行遇到某一个条件就执行当前条件下的代码

```python
age = 18
if 28 >= age >=18:
  if age == 20:
    print(f"go home")
  print(f"go wangba")
elif 38 >= age >=28:
  print(f"go work")
elif 48 >= age >=38:
  print(f"go work")
elif 58 >= age >=48:
  print(f"no work")
else:
  print(f"go die")
```

##### 登录注册练习

让用户输入用户名和密码，检验用户和密码是否正确，正确则打印登录成功，失败就打印登录失败，并且告诉用户是用户名错误还是密码错误

```python
ture_username = "jack"
ture_password = 1024

username = input("Please input Username: ")
password = int(input("Please input Password: "))
if username != ture_username and password != password:
    print(f"登录失败")
elif username != ture_username and password == password:
    print(f"用户名错误")
elif username == ture_username and password != password:
    print(f"密码错误")
else:
    print(f"登录成功")
```

#### 3、循环结构---->循环执行代码

重复执行代码，直至代码达到某个条件才会终止

```python
"""
while 终止条件：
	代码
	让wilie里面的代码一直执行，直到执行到符合终止条件的时候自动终止循环
"""
count = 1
while count < 5:
    print(count)
    count += 1
    
1、关键字 range(起始，结束)
左开右闭，第一个参数不写默认0
生成一个指定区间数字的列表
print(list(range(2,9)))
print(tuple(range(2,9)))
print(set(range(2,9)))
# results
[2, 3, 4, 5, 6, 7, 8]
(2, 3, 4, 5, 6, 7, 8)
{2, 3, 4, 5, 6, 7, 8}

重复执行代码，执行次数
print("hello")
for i in range(0,3):
    print("hello world")

2、关键字continue
搭配 while 循环使用
在 while 循环内部，如果当前条件满足的时候不需要执行跳过即可
count = 0
while count < 5:
    count += 1
    # 等于3跳过打印3
    if count == 3:
        print(f"Good bye{count}")
        continue
    else:
        print(count)

 3、关键字break
当程序循环执行达到某一条件的时候就像结束整个程序
count = 0
while count < 5:
    count += 1
    # 等于3跳过打印3
    if count == 3:
        print(f"Good bye{count}")
        continue
    elif count == 4:
    # 等于4结束循环    
        print(f"Good bye{count}")
        break
    else:
        print(count)
        
4、标志位
tag = True 
pass占位符


5、死循环
while的循环条件一直为真的时候就会一直循环执行
while内部代码，避免出现死循环
while True：
 print(1)
  
  
等同效果
for i in range(0,6):
    print(i)

count = 0
while count < 6:
    print(count)
    count += 1
    
对于可迭代类型：
data_str = [12,22,33,44,55,46,1]
for i in data_str:
    print(i)

count = 0
while count < len(data_str):
    print(data_str[count])
    count += 1
```

##### 作业：

基础

猜年龄，提前给定一个确定的年龄18，

让用户输入年龄， 和真的年龄比较，如果大了就提示大了，反之一致

错误的时候让用户重复尝试3次，3次全部错误再结束程序

进阶

3次结束以后让用户选择是否继续猜，输入是则重复

```python

```





# 04、三元运算

三元表达式是一种简洁的条件判断语法，用于在一行代码中实现简单的 `if-else` 逻辑，核心是根据条件返回不同的值

其实是将 `if-else` 判断语句的简化表达，代替多重 `if-else` 

和 `if-else` 一样，只有一个表达式会被执行

因此，三元表达式中的if和else可以包含大量的计算，但只有true的分支会被执行

### 基本语法

```python
变量 = 表达式1 if 条件 else 表达式2
```

**执行逻辑**：

- 若 `条件` 为 `True`，则结果为 `表达式1`
- 若 `条件` 为 `False`，则结果为 `表达式2`

#### 1. 简单判断与赋值

```python
# 传统if-else写法
age = 20
if age >= 18:
    status = "成年"
else:
    status = "未成年"

# 三元运算简化
status = "成年" if age >= 18 else "未成年"
print(status)  # 输出：成年

# 用到元组或字典上
a, b = 2, 3
# 简化后
print(a if a > b else b)

print((a, b)[a < b])
这个表达式是利用元组索引实现的一种 “伪三元运算”，用于在 a 和 b 中选择较大的值，逻辑等价于：
b if a < b else a（即如果 a < b 则返回 b，否则返回 a）

拆解分析
元组 (a, b)：创建一个包含两个元素的元组，第一个元素是 a，第二个是 b

索引 [a < b]：
a < b 是一个条件判断，结果为布尔值（True 或 False）。
在 Python 中，布尔值可以当作整数使用：True 等价于 1，False 等价于 0。

因此：
若 a < b 为 True，则索引为 1，元组取第二个元素 b。
若 a < b 为 False，则索引为 0，元组取第一个元素 a。

示例验证
a = 3
b = 5
print((a, b)[a < b])  # 输出 5（因3 < 5为True，取索引1对应的b）

a = 7
b = 2
print((a, b)[a < b])  # 输出7（因7 < 2为False，取索引0对应的a）
```

#### 2. 数值计算场景

```python
x, y = 15, 25
# 取两个数中的较小值
min_val = x if x < y else y
print(min_val)  # 输出：15
```

#### 3. 结合复杂表达式

```python
score = 78
# 根据分数返回评级和分数
result = f"良好（{score}分）" if 60 <= score < 90 else f"优秀（{score}分）" if score >= 90 else f"不及格（{score}分）"
print(result)  # 输出：良好（78分）
```

### 嵌套使用注意

三元运算支持嵌套（即 `表达式1` 或 `表达式2` 本身也可以是三元运算），但过度嵌套会降低可读性，建议最多嵌套 1-2 层。

两层嵌套：

```python
num = 0
# 判断正数、负数或零
category = "正数" if num > 0 else "负数" if num < 0 else "零"
print(category)  # 输出：零
```

### 与传统 if-else 的对比

| 场景     | 三元运算                   | 传统 if-else                 |
| -------- | -------------------------- | ---------------------------- |
| 代码长度 | 一行完成                   | 多行代码                     |
| 适用逻辑 | 简单条件判断（单条件分支） | 复杂逻辑（多条件、多语句）   |
| 可读性   | 简单场景更优，复杂场景变差 | 复杂场景更清晰               |
| 返回值   | 必须返回一个值（表达式）   | 可执行语句（如打印、循环等） |

### 常见错误

1. **将语句当作表达式使用**
   三元运算的两端必须是「表达式」（有返回值），不能是「语句」（如 `print()`、`break` 等）：

   ```python
   # 错误示例（print是语句，不是表达式）
   print("yes") if x > 0 else print("no")
   ```

2. **过度嵌套导致可读性差**
   不建议这样写：

   ```python
   res = a if b else c if d else e if f else g
   ```

   最佳实践

- 仅用于简单的单条件判断场景
- 确保表达式简短清晰，一眼能看懂逻辑
- 复杂逻辑（多条件、多步骤操作）优先使用传统 `if-elif-else`



# 05、数据类型的内置方法

### 一、字符串（`str`）—— 不可变类型

字符串方法均返回新字符串（不修改原字符串），常用方法：

| 方法                           | 功能                           | 示例                                 |
| ------------------------------ | ------------------------------ | ------------------------------------ |
| `upper()`                      | 转换为大写                     | `"hello".upper() → "HELLO"`          |
| `lower()`                      | 转换为小写                     | `"HELLO".lower() → "hello"`          |
| `strip([chars])`               | 移除首尾指定字符（默认空白）   | `" abc ".strip() → "abc"`            |
| `split(sep=None, maxsplit=-1)` | 按分隔符分割为列表             | `"a,b,c".split(",") → ["a","b","c"]` |
| `join(iterable)`               | 用字符串连接可迭代对象         | "-".join(["a","b"]) → "a-b"          |
| `replace(old, new, count=-1)`  | 替换子串                       | `"abac".replace("a","x") → "xbxc"`   |
| `find(sub, start=0, end=None)` | 查找子串索引（不存在返回 - 1） | `"hello".find("ll") → 2`             |
| `startswith(prefix)`           | 判断是否以指定前缀开头         | `"hello".startswith("he") → True`    |
| `endswith(suffix)`             | 判断是否以指定后缀结尾         | `"hello".endswith("lo") → True`      |
| `isdigit()`                    | 判断是否全为数字               | `"123".isdigit() → True`             |

```python
优先记住的内置方法
1、字符串的拼接
join()
2、字符串索引取值
正向取值，负向取值，但不支持索引改值
3、字符串切片
按照指定位置将某部分隔离出来
反转字符串[::-1]
4、计算长度
len()
5、成员运算 in / not in
6、去除特殊字符
strip([chars])   lstrip([chars])  rstrip([chars])
7、切分字符串
按照指定的分隔符将字符串进行切割，并且分隔符会消失
split(sep=None, maxsplit=-1)
user_pwd = "username:password"
username, password = user_pwd.split(":")
print(f"username:>>> {username}")
print(f"password:>>> {password}")
8、遍历字符串
for循环
while 循环索引取值
9、字符串重复
a*b
10、大小写转换
upper() 大写
lower()	小写
11、首位字符串判断
print("username".startswith("a"))
print("password".endswith("c"))
12、格式化输出语法
f"{}"
%s
format
13、替换指定字符
print("username".replace("a","1"))
14、判断字符串是否全为数字
isdigit()

了解的内置方法
1、查找某个字符所在位置的索引
find(),存在重复，不会继续，如果不存在则返回-1
index（），不存在则直接报错
2、统计当前字符出现的次数
count()
3、填充
两侧填充 center(原数据长度，需要填充的字符)
如果是奇数，优先右，然后左
4、添加对齐
rjust（原数据长度，需要填充的字符）
ljust（原数据长度，需要填充的字符）
5、填充0
zfill(原数据长度+需填充的长度)
默认使用0填充至指定的长度，从左往右填充
6、首字母大写
capitalize()
7、大小写反转
swapcase()
8、首字母大写
title()，字符间需要空格，否则不生效


```



### 二、列表（`list`）—— 可变类型

列表方法会修改原列表（除非特别说明），常用方法：

| 方法                            | 功能                                        | 示例                                    |
| ------------------------------- | ------------------------------------------- | --------------------------------------- |
| `append(x)`                     | 在末尾添加元素                              | `[1,2].append(3) → [1,2,3]`             |
| `insert(i, x)`                  | 在索引 `i` 处插入元素                       | `[1,3].insert(1,2) → [1,2,3]`           |
| `extend(iterable)`              | 合并另一个可迭代对象                        | `[1,2].extend([3,4]) → [1,2,3,4]`       |
| `remove(x)`                     | 移除第一个值为 `x` 的元素                   | `[1,2,2].remove(2) → [1,2]`             |
| `pop(i=-1)`                     | 移除并返回索引 `i` 处的元素（默认最后一个） | `[1,2,3].pop() → 3`（列表变为 `[1,2]`） |
| `sort(key=None, reverse=False)` | 原地排序（`reverse=True` 降序）             | `[3,1,2].sort() → [1,2,3]`              |
| `reverse()`                     | 原地反转列表                                | `[1,2,3].reverse() → [3,2,1]`           |
| `index(x)`                      | 返回第一个值为 `x` 的索引                   | `[1,2,3].index(2) → 1`                  |
| `count(x)`                      | 统计 `x` 出现的次数                         | `[1,2,2,3].count(2) → 2`                |
| `clear()`                       | 清空列表                                    | `[1,2].clear() → []`                    |

### 三、元组（`tuple`）—— 不可变类型

元组不可修改，方法较少：

| 方法       | 功能                  | 示例                   |
| ---------- | --------------------- | ---------------------- |
| `count(x)` | 统计 `x` 出现的次数   | `(1,2,2).count(2) → 2` |
| `index(x)` | 返回第一个 `x` 的索引 | `(1,2,3).index(2) → 1` |

### 四、字典（`dict`）—— 可变类型

字典方法用于操作键值对，常用方法：

| 方法                            | 功能                                            | 示例                                                        |
| ------------------------------- | ----------------------------------------------- | ----------------------------------------------------------- |
| `get(key, default=None)`        | 获取键 `key` 的值，不存在返回 `default`         | `{"a":1}.get("b", 0) → 0`                                   |
| `keys()`                        | 返回所有键的视图                                | `{"a":1,"b":2}.keys() → dict_keys(['a','b'])`               |
| `values()`                      | 返回所有值的视图                                | `{"a":1,"b":2}.values() → dict_values([1,2])`               |
| `items()`                       | 返回所有键值对的视图（`(key, value)` 元组）     | `{"a":1}.items() → dict_items([('a',1)])`                   |
| `update(other)`                 | 用 `other` 字典更新当前字典（覆盖已有键）       | `d={"a":1}; d.update({"b":2}) → {"a":1,"b":2}`              |
| `pop(key, default)`             | 删除并返回键 `key` 的值，不存在返回 `default`   | `{"a":1}.pop("a") → 1`（字典变为 `{}`）                     |
| `popitem()`                     | 删除并返回最后插入的键值对（3.7+ 有序）         | `{"a":1,"b":2}.popitem() → ('b',2)`                         |
| `clear()`                       | 清空字典                                        | `{"a":1}.clear() → {}`                                      |
| `setdefault(key, default=None)` | 若键不存在则添加 `key:default` 并返回 `default` | `{"a":1}.setdefault("b",2) → 2`（字典变为 `{"a":1,"b":2}`） |

### 五、集合（`set`）—— 可变类型

集合方法用于操作唯一元素和集合运算：

| 方法                  | 功能                             | 示例                              |                                  |
| --------------------- | -------------------------------- | --------------------------------- | -------------------------------- |
| `add(x)`              | 添加元素 `x`（已存在则忽略）     | `{1,2}.add(3) → {1,2,3}`          |                                  |
| `update(iterable)`    | 添加多个元素                     | `{1,2}.update([3,4]) → {1,2,3,4}` |                                  |
| `remove(x)`           | 删除 `x`（不存在则报错）         | `{1,2}.remove(2) → {1}`           |                                  |
| `discard(x)`          | 删除 `x`（不存在则忽略）         | `{1,2}.discard(3) → {1,2}`        |                                  |
| `pop()`               | 随机删除并返回一个元素           | `{1,2,3}.pop() → 1`（结果随机）   |                                  |
| `union(other)`        | 返回与 `other` 的并集（`a        | b`）                              | `{1,2}.union({3,4}) → {1,2,3,4}` |
| `intersection(other)` | 返回与 `other` 的交集（`a & b`） | `{1,2,3} & {2,3,4} → {2,3}`       |                                  |
| `difference(other)`   | 返回与 `other` 的差集（`a - b`） | `{1,2,3} - {2} → {1,3}`           |                                  |
| `clear()`             | 清空集合                         | `{1,2}.clear() → set()`           |                                  |

### 六、整数（`int`）与浮点数（`float`）

数字类型方法较少，主要用于转换和特性判断：

| 类型    | 方法                          | 功能                         | 示例                                        |
| ------- | ----------------------------- | ---------------------------- | ------------------------------------------- |
| `int`   | `bit_length()`                | 返回二进制表示的位数         | `8.bit_length() → 4`（8 的二进制是 `1000`） |
| `int`   | `to_bytes(length, byteorder)` | 转换为字节序列               | `65.to_bytes(1, 'big') → b'A'`              |
| `float` | `is_integer()`                | 判断是否为整数（如 `5.0`）   | `5.0.is_integer() → True`；`5.5 → False`    |
| `float` | `as_integer_ratio()`          | 返回分子和分母组成的分数元组 | `0.5.as_integer_ratio() → (1, 2)`           |

```python
1、强制类型转换
num_str = "55"
num_str_int = int(num_str)
print(num_str, type(num_str))
print(num_str_int, type(num_str_int))

print(float("1.23"))
print(type(float("1.23")))

2、进制转换
2,8,10,16进制
print(bin(99)) 2
print(oct(99)) 8
print(hex(99)) 16

3、int也能做类型转换
int(x, base) 函数用于将字符串 x 按照指定的进制 base 转换为十进制整数
其中：
	base 表示字符串 x 所采用的进制（取值范围通常为 2~36）。
	字符串 x 中的字符必须符合 base 进制的规则（例如，二进制只能包含 0 和 1）
  
方法补充
1、判断当前字符串是否符合整数类型格式
num1 = b'4'   
num2 = '5'
num3 = '四'
num4 = 'Ⅳ'
print(num1,type(num1))
# 判断当前数字是否符合数字类型
print(num1.isdigit()) 		T
print(num2.isdigit()) 		T
print(num3.isdigit()) 		F
print(num4.isdigit()) 		F

# 判断当前字符串
print(num1.isdecimal())

没有判断是否为浮点数的方法

age = input("请输入年龄：》》》")
if age.isdigit():
    age = int(age)
else:
    print(f"当前{age}不是合法的数字")
    
```



### 总结

- **不可变类型**（`str`、`tuple`、`int`、`float`）的方法均返回新对象，不修改原对象；
- **可变类型**（`list`、`dict`、`set`）的方法大多直接修改原对象（如 `append`、`update`）；
- 方法的命名通常反映其功能（如 `xxx` 相关的 `count`、`index` 在多类型中通用），便于记忆